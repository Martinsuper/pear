---
title: JIMDB 基础
date: 2024-09-18 17:19:25
order: 2
tags: 
    - JIMDB
    - 缓存
---
## JIMDB 介绍

JIMDB是一款基于Redis研发的，具备高性能、高可用、在线伸缩能力的分布式缓存服务。JIMDB服务于京东集团内各BG/BU，适用于高吞吐、低延迟的业务场景。

## JIMDB 架构

![20240918172108](https://raw.githubusercontent.com/superdly/image-bed/pear/2024/20240918172108.png)



1. **JIMDB：JIMDB是一款基于Redis研发的，具备高性能、高可用、在线伸缩能力的分布式缓存服务。**JIMDB服务于京东集团内各BG/BU，适用于高吞吐、低延迟的业务场景。
2. **CFS：Config Server的缩写，是JIMDB的元数据服务；**JIMDB集群的拓扑状态和客户端配置存储在CFS中，JIMDB的SDK或者AP通过CFS获取集群元数据，来保障能够读写到正确的数据节点。
3. **JimUrl：JimUrl是JIMDB集群的标识和密码；**应用里通过配置jimURL来访问特定JIMDB集群；正式环境的JimUrl需要妥善保管，任何人拿到您的JimUrl后都可以访问您的JIMDB集群。
4. **分片：一个分片是一组具有主从关系的JIMDB Server；**业务数据按照一定的路由规则分布在不同的分片。通过调整分片数量来实现集群的扩缩容，目前JIMDB最多支持2048分片。
5. **副本**: **一个分片的主节点或者该分片的某个从节点称为一个副本；**常见的表达是给某个分片添加/删除一个副本或者给某个集群添加/删除**一组副本**（这里的一组副本指的是每个分片各一个副本）。
6. **副本组：一个JIMDB集群下所有分片的同一位置副本可以称作一个副本组；**一般集群下所有分片的主节点是m副本组、所有分片的第0个从节点是s0副本组、所有分片的第1个从节点是s1副本组……以此类推；副本组功能主要用来实现读写分离、负载均衡、应用在机房垂直访问等。**在实际沟通中，更多的用“m副本”代指“m副本组”、用“s0副本”代指“s0副本组”......。**
7. **读组：读组是副本组的一种别名，类似的一个JIMDB集群下一般有m、s0、s1……读组；**在日常工作中，我们经常在m、s0、s1……等不同的副本组之间调度读流量，**所以习惯把副本组称之为读组；并且读组这个概念使用更为广泛**；需要注意的是，包含了所有分片主节点的m读组不仅提供了读能力，也提供了写能力，但是按照习惯也会称之为m读组。
8. **AP：Access Proxy的缩写，是JIMDB的访问代理；**AP内部实现JIMDB集群的分片管理和数据路由，对外提供了标准的Redis服务，应用可以使用标准Redis的SDK访问AP而无需关心JIMDB的分片和路由逻辑。通过AP访问JIMDB集群，相对于通过SDK访问，性能有损失。
9. **ClientConfig：JIMDB的客户端配置，管理着JIMDB的动态参数；**一个JIMDB集群可以创建一个或者多个ClientConfig，并以不同的ID来区分（比如config 0、config 1等）；用户可以在泰山平台调整某个ClientConfig下的动态参数。不同应用可以根据业务场景引用不同的ClientConfig来访问同一个JIMDB集群。
10. **C SDK：JIMDB C/C++ SDK的一种口语表达，在文档中一般使用JIMDB C/C++ SDK**；C/C++的应用可以引入JIMDB的C/C++ SDK访问JIMDB集群。
11. **大Key：大于1M或者Value超过5000个元素的一个KV存储；**这是一个建议标准，在实际生产环境中，大Key对集群的影响还需考虑Key的访问频次，Key大且访问频次高容易超过JIMDB集群限流（200M/s限流）或者把JIMDB Server CPU打满，导致线上服务受影响。

## 对比 Redis 优缺点

| 特性     | 场景                                                         | JIMDB                                                        | Redis Cluster                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------- |
| 集群规模 | 零售业务存在大规模数据存储需求，需要多个存储节点支撑         | 单集群支持2048分片，1w+节点。通过水平扩容支撑业务数据量增大，最大可支撑上亿OPS。 | 单集群能支撑400-600节点，水平扩容能力有限。         |
| 热key    | 抢购、秒杀类业务存在单个key的热点读问题，访问量超过单个实例能承担的上限后，性能和可用率急剧下降。 | 在服务端直接支持热key的自动发现，并通知客户端缓存热key，极大提升热读能力。 | 不支持该特性                                        |
| 读写分离 | 单个副本提供读服务的能力有限，需要通过多副本承载流量         | 支持读写分离；支持轮询、随机负载均衡策略；支持客户端分组，每个分组使用不同策略 | 需要业务自行实现                                    |
| 单连接   | 几乎所有的开源SDK都使用了阻塞IO的方式访问redis，需要使用连接池。连接池配置复杂，不同业务访问行为不同，需要根据压测情况调节。如果出现突发流量，还会造成连接风暴问题，服务不可用。 | JAVA SDK1.x使用了连接池方式配置，我们常常需要协助业务对连接池调优。JAVA SDK2.x使用NIO方式，每个客户端每个实例只保持一条连接，彻底解决连接风暴问题。业务无需配置化连接池。服务端上的连接数量大大减少。 | 开源JAVA SDK中使用最广泛的Jedis，使用的连接池模式。 |
| 预建连接 | 应用刚启动时，访问缓存需要新建连接，会发生抖动，需要提前预热连接。 | JAVA SDK2.x提供了预建连接策略，在连接预建好之后，业务才能启动并提供服务。 | 开源SDK未提供这种能力                               |
| 异步API  | 业务访问缓存，等待响应的期间无法响应新的请求，需要额外的线程支撑。这会增大业务进程的内存开销，增大线程切换的CPU开销。 | JAVA SDK2.x支持了异步API，业务发起请求之后可以继续处理后续请求，无需等待响应。当响应到达时，SDK会唤醒业务处理该响应。 | Jedis不支持异步API                                  |
| 在线伸缩 | 集群扩容、缩容、故障迁移、机器调整等操作都涉及到数据从一个实例移动到另一个实例。数据移动需要在不停业务的情况下完成。 | 实例移动过程中，每个客户端最多切换一次拓扑，业务几乎无感知。业务可以按需申请资源，无需担心资源伸缩对性能的影响。 | 实例移动整个过程中，业务会一直有明显卡顿。          |





###### IMDB实例故障主要原因

- 日常运维手动触发
- 硬件故障、网络故障等导致的哨兵判死
- 大/热Key导致缓存区打满触发OOM kill、哨兵判死

### 二、JIMDB探活机制

实例故障是通过哨兵（探活组件）主动发现的，每个机房都部署了一组由5个哨兵组成的探活团队，并通过投票来决定实例的存活状态并通知Failover（故障恢复组件）。为了避免业务命令阻塞导致误判，这些哨兵会通过一个独立的管理端口对实例进行探活，探活时间间隔为1s

###### 1.哨兵的判死机制：赞成票大于一半且没有反对票，判死时长20s

1. 超过一半哨兵任务JIMDB实例已死（线上一组哨兵5个节点）；
2. 没有任何哨兵认为JIMDB实例存活；
3. 满足条件1和条件2，并持续至少20秒（中间不能有间断）。

注意：哨兵判断实例故障后会通知Failover组件，Failover会进行二次确认。
