---
title: 使用JIMDB的优势和限制
date: 2024-09-18 17:27:19
order: 2
tags: 
    - JIMDB
---

# 使用JIMDB的优势

## 一、高性能

| 特性     | 场景                                                         | JIMDB                                                        | Redis Cluster                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------- |
| 集群规模 | 零售业务存在大规模数据存储需求，需要多个存储节点支撑         | 单集群支持2048分片，1w+节点。通过水平扩容支撑业务数据量增大，最大可支撑上亿OPS。 | 单集群能支撑400-600节点，水平扩容能力有限。         |
| 热key    | 抢购、秒杀类业务存在单个key的热点读问题，访问量超过单个实例能承担的上限后，性能和可用率急剧下降。 | 在服务端直接支持热key的自动发现，并通知客户端缓存热key，极大提升热读能力。 | 不支持该特性                                        |
| 读写分离 | 单个副本提供读服务的能力有限，需要通过多副本承载流量         | 支持读写分离；支持轮询、随机负载均衡策略；支持客户端分组，每个分组使用不同策略 | 需要业务自行实现                                    |
| 单连接   | 几乎所有的开源SDK都使用了阻塞IO的方式访问redis，需要使用连接池。连接池配置复杂，不同业务访问行为不同，需要根据压测情况调节。如果出现突发流量，还会造成连接风暴问题，服务不可用。 | JAVA SDK1.x使用了连接池方式配置，我们常常需要协助业务对连接池调优。JAVA SDK2.x使用NIO方式，每个客户端每个实例只保持一条连接，彻底解决连接风暴问题。业务无需配置化连接池。服务端上的连接数量大大减少。 | 开源JAVA SDK中使用最广泛的Jedis，使用的连接池模式。 |
| 预建连接 | 应用刚启动时，访问缓存需要新建连接，会发生抖动，需要提前预热连接。 | JAVA SDK2.x提供了预建连接策略，在连接预建好之后，业务才能启动并提供服务。 | 开源SDK未提供这种能力                               |
| 异步API  | 业务访问缓存，等待响应的期间无法响应新的请求，需要额外的线程支撑。这会增大业务进程的内存开销，增大线程切换的CPU开销。 | JAVA SDK2.x支持了异步API，业务发起请求之后可以继续处理后续请求，无需等待响应。当响应到达时，SDK会唤醒业务处理该响应。 | Jedis不支持异步API                                  |
| 在线伸缩 | 集群扩容、缩容、故障迁移、机器调整等操作都涉及到数据从一个实例移动到另一个实例。数据移动需要在不停业务的情况下完成。 | 实例移动过程中，每个客户端最多切换一次拓扑，业务几乎无感知。业务可以按需申请资源，无需担心资源伸缩对性能的影响。 | 实例移动整个过程中，业务会一直有明显卡顿。          |

## 二、高可用

| 特性                | 场景                                                         | JIMDB                                                        | Redis Cluster                    |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------- |
| 故障检测            | 发现故障实例                                                 | 哨兵与实例分离，每组哨兵可支撑10w实例的检测，可以通过增加分组水平扩容 | 实例相互探活，支撑规模小         |
| 检测准确性          | redis是单线程模型，大key访问可能造成阻塞导致误判             | JIMDB服务端启动单独端口提供探活服务，避免误判                | 原生redis使用的命令端口探活      |
| 故障迁移策略        | 故障迁移在补齐副本的时候会从源端复制数据，影响源端性能。     | JIMDB提供了保读/保写策略，根据不同策略，选择不同的副本复制数据，保障业务的读/写。 | 没有对故障迁移提供额外的性能保障 |
| 故障迁移熔断        | 线上出现过大规模网络故障                                     | JIMDB识别到大规模网络故障发生，会自动熔断自动故障迁移（不再自动切换），避免大量存活实例发生故障切换。当明确了故障范围和业务接受程度后，再决策是否恢复熔断。 |                                  |
| 流量控制            | 单个实例流量太大会影响同一台物理机上的其他实例               | 支持出、入流量控制                                           | 不支持                           |
| SDK自动摘除故障节点 | 线上发生过因为机器网卡问题导致实例性能抖动，但是哨兵无法将其判死，业务可用率持续收到影响 | JAVA SDK提供了节点抖动和故障检测、摘除功能。如果对某个节点访问连续5次超时，SDK不再向该节点发送请求，直到连续三次探测成功。 | 开源SDK没有节点抖动容错能力      |
| 动态配置            | 可以在业务不重启应用的情况下，改变客户端的行为               | JIMDB SDK会通过元数据服务，保持获取最新的配置并应用          | 开源SDK没有类似能力              |
| DRC                 | 异地多活能力                                                 | 设计了专门的协议，可以减少全量复制的发生、降低带宽打满的风险 | 开源版本不支持，企业版支持       |

## 三、易运维

### 1、运维工具

- 监控告警：完善的监控、丰富的告警策略，确保告警有效、高效触达
- 故障预案：一键切机房、切分片、切分副本组、切集群
- 平台工具：大/热key扫描工具、数据备份、慢日志订阅、冷数据扫描、集群间数据对比、主从数据对比

### 2、运维自动化

- 自动巡检：拓扑一致性、锁泄露
- 自动运维：资源自动回收、不合理部署自动校正
- 智能调度：自动内存均衡、实例分布均衡

### 3、集群可观测

- 秒级监控：定制轻量级的采集命令，通过管理端口提供服务，业务无影响。
- 客户端埋点：从客户端和服务器两个维度分析tp性能，方便找到性能问题。
- 业务线看板：从业务视角观察多个JIMDB集群的工作状态。
